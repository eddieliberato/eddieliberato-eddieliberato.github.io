[{"categories":["Computer aided design"],"contents":"This design may be simple but it is useful, I can attest.\nThe price estimations that I received for this object, made out of welded steel, were in the 100-130 EUROS range, 10 days delivery time. As the application intended for it had a moderately light load I decided to just model and 3d print it. Took me half an hour of 3d modeling and 4 hours for the 3d printing process. I printed it out of ABS on a professional grade printer from the university.\nimport cadquery as cq width = 66.0 # mm fplate_height = 60.0 # mm fplate_thickness = 10.0 # mm fplate_between_holes = 47.1 # mm, rectangular distance between stepper mounting holes (NEMA 23 = 47.1) fplate_screw_clearance = 5.0 # mm fplate_cbore_diameter = 7.5 # mm fplate_cbore_depth = 4.0 # mm main_bore_diameter = 28.2 # mm main_cbore_diameter = 40.0 # mm main_cbore_depth = 2.0 # mm bplate_length = 86.0 # mm bplate_thickness = 4.0 # mm bplate_between_holes = 50.0 # mm, holes to mount it to the frame bplate_holes_offset = 5.0 # mm bplate_screw_clearance = 5.0 # mm bplate_cbore_diameter = 7.5 # mm bplate_cbore_depth = 2.0 # mm rib_thickness = 3.0 # mm reinforcement_gusset = True stepper_bracket = cq.Workplane(\u0026#34;front\u0026#34;).box(width, fplate_thickness, fplate_height+bplate_thickness) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().move(0, bplate_thickness/2).rect(fplate_between_holes, fplate_between_holes, forConstruction=True) .\\ vertices().cboreHole(fplate_screw_clearance, fplate_cbore_diameter, fplate_cbore_depth) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().move(0, bplate_thickness/2).cboreHole(main_bore_diameter, main_cbore_diameter, main_cbore_depth) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -fplate_height/2).rect(width, bplate_thickness).extrude(bplate_length) .\\ faces(\u0026#34;\u0026lt;Z[1]\u0026#34;).workplane().move(0, bplate_holes_offset).rect(bplate_between_holes, bplate_between_holes, forConstruction=True) .\\ vertices().cboreHole(bplate_screw_clearance, bplate_cbore_diameter, bplate_cbore_depth) if reinforcement_gusset: stepper_bracket = stepper_bracket.faces(\u0026#34;\u0026gt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -(fplate_height+bplate_thickness)/2) .\\ line((bplate_length+fplate_thickness)/2, 0).line(0, fplate_height).close().extrude(-rib_thickness) .\\ faces(\u0026#34;\u0026lt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -(fplate_height+bplate_thickness)/2) .\\ line(-(bplate_length+fplate_thickness)/2, 0).line(0, fplate_height).close().extrude(-rib_thickness) ","permalink":"https://eddieliberato.github.io/blog/2020-08-01-stepper-motor-bracket/","tags":["3d printing","Cadquery","Cad"],"title":"Parametric Stepper Motor Bracket"},{"categories":["Computer aided design"],"contents":"Last month I had the pleasure to visit Ireland and spend some quality time with a special person while exploring this enchanting land. As I was in Europe I decided to buy myself a raspberry pi and an official touchscreen. My goal was to evaluate if using this SBC as a replacement for a desktop computer for simple things like web browsing and of course to play some retro games.\nI knew I\u0026rsquo;d have to come up with some way of mounting the screen and my plan was just to 3d print something from internet. What I didn\u0026rsquo;t expect was that I\u0026rsquo;d find my big 3d printer out of order once back home. This left me only with my small 3d printer ( 100 x 100 mm printing area ) making hard to find a suitable 3d model of a stand.\nCadquery to the rescue. My idea was to make something minimalist and break it down into small pieces. The support itself is a piece of a Brazilian wood called \u0026ldquo;cedrinho\u0026rdquo; with a 60° cut. No special reason for the size, It\u0026rsquo;s just what I had at hand.\nThe 3d printed parts are the coupler and the pads. The coupler makes the bridge between the threaded holes on the metal backing of the screen and the wood piece. The pads are just to prevent the screen of touching the desk directly.\nI used pla for the coupler ( man, this purple pla is lasting forever lol ) and the pads are printed using a very interesting filament made by the folks at RappersWil Technical College. It\u0026rsquo;s a flexible TPU made out of recycled skying boots ( lol again ), and I\u0026rsquo;ll tell you what, It just works.\nI\u0026rsquo;m not trying to be a blogger or something alike here, but this creamelt guys have some interesting materials available.\nHere follows the script for the 3d models.\nimport cadquery as cq pi_support = cq.Workplane(\u0026#34;front\u0026#34;).box(10.0, 5.0, 65.65+10.0) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().pushPoints([(0, 65.65/2.0), (0,-65.65/2)]).cboreHole(4.0, 7.5, 2.0) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().rect(17.8+2.5, 43.0+2.5).extrude(-5.0) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().rect(17.8+2.5, 43.0+2.5).rect(17.8, 43.0).extrude(10.0) .\\ edges(\u0026#34;\u0026gt;X and |Y\u0026#34;).chamfer(1.0).edges(\u0026#34;\u0026lt;X and |Y\u0026#34;).chamfer(1.0) .\\ edges(\u0026#34;\u0026gt;Z and |Y\u0026#34;).chamfer(2.0).edges(\u0026#34;\u0026lt;Z and |Y\u0026#34;).chamfer(2.0) pad = cq.Workplane(\u0026#34;front\u0026#34;).box(8.0, 20.0, 6.0) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().rect(1.2, 20.0).cutBlind(-4.0) .\\ edges(\u0026#34;\u0026lt;Z and |Y\u0026#34;).fillet(3.0).translate((-10,30,0)) The last piece of the puzzle is a smalll piece of wood with a 60° angle cut. In order to cut that I used a guide that I actually printed in the past, but so far didn\u0026rsquo;t share the script. If you\u0026rsquo;re curious about how to use this thing you can watch this video from David Barron ( he\u0026rsquo;s talking about a 45° guide, I used a 60° guide, though).\nimport cadquery as cq from math import sqrt # A simple 60 degrees hand saw guide for woodworking  size = 35.0 # mm, height and lenght and of the guide. The width is double this value tab_top = 18.0 # mm, thickness of the top tab tab_back = 12.0 # mm, thickness of the back tab magnet_diameter = 5.2 # mm magnet_thickness = 8.7 # mm  magnet_spacing_between = 30.0 # mm clearance = True clearance_size = 2.0 # mm guide2 = cq.Workplane(\u0026#34;front\u0026#34;).line(size*sqrt(3), 0).line(-size*sqrt(3), size).close().extrude(size).\\ faces(\u0026#39;\u0026gt;(1,1,0)\u0026#39;).workplane().pushPoints([(-magnet_spacing_between/2, size/2-tab_top/2), (magnet_spacing_between/2, size/2-tab_top/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().transformed(offset=(0, -tab_top, -tab_back)).rect(size*2, size).cutBlind(-size) if clearance: guide2 = guide2.faces(\u0026#39;\u0026gt;(1,1,0)\u0026#39;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -tab_top).rect(size*2, size).cutBlind(-clearance_size) guide2 = guide2.faces(\u0026#34;\u0026lt;X\u0026#34;).workplane(-50).rect(size, size*2).cutBlind(-30.0) guide2 = guide2.faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane(-30).rect(size*2, size*2).cutBlind(-30.0) This is only a temporary solution, but hey, It works. Now I can explore this SBC and decide which application on my list of projects suits it the best.\nCheers!\n","permalink":"https://eddieliberato.github.io/blog/2020-06-26-minimalist-stand-for-raspberry-pi/","tags":["3d printing","Cadquery","Cad"],"title":"Minimalist Raspberry Pi Stand "},{"categories":["Microcontrollers"],"contents":"This post is about how I got STM32cubeIDE up and running on Ubuntu 20.04. It is meant more as a note to myself in case I need to install this software in different machines but also can be useful for someone that strumbled across the same problems.\nDownloading and installing the software from the STM website is straightfoward. A bit annoyoning but straightfoward.\nAfter starting the software you land on a GUI interface where you can select some microcontroller initialization options. The ones I selected in order to run the board and blink the built-in LED (PIN 13) are listed bellow.\n Under RCC tab, select crystal / Ceramic resonator as High speed Clock (HSE) Under SYS Debug tab, choose Serial Wire Set up PIN 13 as GPIO output On the tab clock, route the system through PLLclock and set the clock to 72 MHz  The software creates the initialization code automatically but when compiling and trying to start the debugger the first error I encountered was:\n Could not determine GDB version using command: / opt/ st/stm32cubeide_1.3.0 /plugins /com. st. stm32cube. ide. mcu. externaltools. gnu-tools-for-stm32.7-2018-q2-update.linux64_1.0.0.201904181610 /tools /bin /arm-none-eabi-gdb \u0026ndash;version /st /stm32cubeide_1.3.0 /plugins /com .st .stm32cube .ide .mcu .externaltools .gnu-tools-for-stm32.7-2018-q2-update.linux64_1.0.0.201904181610 /tools /bin /arm-none-eabi-gdb: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory\n Turns out that you need to install GDB debugger yourself because it\u0026rsquo;s not included by default in the STM32cubeIDE. The problem is that it isn\u0026rsquo;t possible to find the package anymore in the apt package manager. The solution is to install it manually as described here by an user called Aleksander Khoroshko.\nYou need to download the tools directly from the ARM website. At the time of writing this was the latest release.\nThe specific commands for the installation on my system (Ubuntu Focal, using the latest release of the ARM tools at the time of writing)\nsudo apt remove gcc-arm-none-eabi sudo tar xjf gcc-arm-none-eabi-9-2020-q2-update-x86_64-linux.tar.bz2 -C /usr/share/ sudo ln -s /usr/share/gcc-arm-none-eabi-9-2020-q2-update/bin/arm-none-eabi-gcc /usr/bin/arm-none-eabi-gcc sudo ln -s /usr/share/gcc-arm-none-eabi-9-2020-q2-update/bin/arm-none-eabi-g++ /usr/bin/arm-none-eabi-g++ sudo ln -s /usr/share/gcc-arm-none-eabi-9-2020-q2-update/bin/arm-none-eabi-gdb /usr/bin/arm-none-eabi-gdb sudo ln -s /usr/share/gcc-arm-none-eabi-9-2020-q2-update/bin/arm-none-eabi-size /usr/bin/arm-none-eabi-size sudo apt install libncurses-dev sudo ln -s /usr/lib/x86_64-linux-gnu/libncurses.so.6 /usr/lib/x86_64-linux-gnu/libncurses.so.5 sudo ln -s /usr/lib/x86_64-linux-gnu/libtinfo.so.6 /usr/lib/x86_64-linux-gnu/libtinfo.so.5 SOLVED! Well, not really. At least not for me, yet. It seems to solve the problem of the GDB dependencies but it fails to communicate with the debugger bringing the following error message.\n Open On-Chip Debugger 0.10.0+dev-01193-g5ce997d (2020-02-20-10:54) Licensed under GNU GPL v2 For bug reports, read http://openocd.org/doc/doxygen/bugs.html none separate Info : The selected transport took over low-level target control. The results might differ compared to plain JTAG/SWD adapter speed: 8000 kHz adapter_nsrst_delay: 100 Info : Listening on port 6666 for tcl connections Info : Listening on port 4444 for telnet connections Info : clock speed 8000 kHz Info : STLINK V2J17S4 (API v2) VID:PID 0483:3748 Info : using stlink api v2 Info : Target voltage: 3.246778 Info : SRST line released Warn : UNEXPECTED idcode: 0x2ba01477 Error: expected 1 of 1: 0x1ba01477\n The key to understand this error is in the end of the error message. A close examination on the label on the chip of my board reviews that I don\u0026rsquo;t have a STM32f103C8T6 but a clone, namely, CS32f103C8T6 from China Key Systems. Not that I was surprised, considering I paid less than 2 US$ for it.\nThis board holds the SW-DP TAP ID 0x2ba01477 instead of the original 0x1ba01477. To fix this you need to change the .cfg file accordingly.\nHere\u0026rsquo;s how I proceeded. First I had to find the file in the system and for this I used the locate command. Before I had to update the database considering I just installed the new software.\nsudo updatedb locate stm32f1x.cfg Beautifully returned the following location\n /opt /st /stm32cubeide_1 .3 .0 /plugins /com .st .stm32cube .ide .mcu .debug .openocd 1.3.0.202002181050 /resources /openocd /st_scripts /target /stm32f1x.cfg\n from there I just had to open this file and change\nset_CPUTAPID 0x1ba01477 to\nset_CPUTAPID 0x2ba01477 Blue Skies from there! Everything works as supposed. The only problem now is that I actually decided to not use this software anymore.\nI\u0026rsquo;m setting this environment for a simple hobby project, so it\u0026rsquo;s not that I\u0026rsquo;m forced to code in C. While googling about this board I actually discovered that it\u0026rsquo;s possible to run FORTH on it. I thought that was an amazing opportunity to play with it and learn more. I always liked FORTH very much and it was the first programming language I interacted with. To tell the truth it wasn\u0026rsquo;t FORTH but a language based on it, RPL on the HP50g, but anyway, I always liked it.\nI decided to give it a try on the bluepill and so far I never regretted it. I recommend to everyone that owns a bluepill board to at least try it once.\nCheers,\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2020-06-02-bluepill-on-ubuntu/","tags":["C","Programming","Electronics","Ubuntu","Embedded"],"title":"Debugging STM32f103C8T6 Bluepill (Ubuntu 20.04)"},{"categories":["Computer Aided Design"],"contents":"One of my personal favorite uses of 3d printers at home is to fix broken stuff. This object is not special but I\u0026rsquo;m posting it here because it envolves modeling parametric threads.\nModeling parametric threads can be undertaking. On top of that if you have to model a thread, it is probably some funky special thread. Overall I\u0026rsquo;m happy with how this trapezoidal thread came out, but I\u0026rsquo;m not sure whether this is the best way to design threads in Cadquery.\nimport cadquery as cq from math import sin, cos, pi lenght = 32 minor_diameter = 18.0 pitch = 4.9 pts = [] for t in range(lenght): x = minor_diameter/2*cos(t) y = minor_diameter/2*sin(t) z = pitch/(2*pi)*t # helix lenght pts.append([x,y,z]) path = cq.Workplane(\u0026#34;XY\u0026#34;).spline(pts).wire() thread = cq.Workplane(\u0026#34;XZ\u0026#34;).move(minor_diameter/2, 0).line(3.2, 0.5).line(0,1.0).line(-3.2, 0.5).close().sweep(path, isFrenet=True) foot = cq.Workplane(\u0026#34;XY\u0026#34;).circle(18.5/2.0).extrude(26.0) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().circle(25.0/2.0).extrude(5.0) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().polygon(8.0, 44.0).extrude(14.0) .\\ faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().hole(14.0, 42.0).translate((0,0,pitch/2.0)) foot = foot.union(thread) show_object(foot) This object is a washing machine adjustment pad that went missing (don\u0026rsquo;t ask me how). At least there was 3 left so I could replicate the missing one. The tolerance on the mating thread was big, because even printing without support on my cheap 3d printer it worked first time! No second iteration was needed :)\n","permalink":"https://eddieliberato.github.io/blog/2020-05-15-man-against-washing-machine/","tags":["cadquery","python","3D printing","CAD"],"title":"Man Against (Washing) Machine"},{"categories":["Computer Aided Design"],"contents":"No need to say much about the classical ASTM D638 tensile test specimens AKA dogbones.\nType I, II, III, and V have the same shape but different dimensions. Type I is usually seem injection molded, type V cut using punch dies. Type IV, actually the one I was after, is intended for non-rigid plastics. Thickness of 3.2 mm is recommended for injection molded specimens.\nimport cadquery as cq # ASTM D638 typeI dogbone W = 13.0 L = 57.0 WO = 19.0 LO = 165.0 R = 76.0 thickness = 3.2 dogbone_typeI = cq.Workplane(\u0026#34;front\u0026#34;).box(LO, WO, thickness) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().rect(L, thickness).cutBlind(-(WO-W)/2) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().rect(L, thickness).cutBlind(-(WO-W)/2) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().rect(L, 2*R+W, forConstruction=True) .\\ vertices().hole(2*R) show_object(dogbone_typeI) import cadquery as cq # ASTM D638 typeIV dogbone W = 6.0 L = 33.0 WO = 19.0 LO = 115.0 R = 14.0 RO = 25.0 thickness = 3.2 dogbone_typeIV = cq.Workplane(\u0026#34;front\u0026#34;).box(LO, WO, thickness) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().rect(L, thickness).cutBlind(-(WO-W)/2) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().rect(L, thickness).cutBlind(-(WO-W)/2) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().rect(L, 2*R+W, forConstruction=True) .\\ vertices().hole(R*2) .\\ edges(\u0026#34;|Z\u0026#34;).edges(\u0026#34;not \u0026lt;X or \u0026gt;X\u0026#34;).fillet(RO) show_object(dogbone_typeIV) Edi\n","permalink":"https://eddieliberato.github.io/blog/2020-05-14-dogbones/","tags":["cadquery","python","3D printing","CAD"],"title":"ASTM D638 Tensile Test Specimens"},{"categories":["Computer Aided Design"],"contents":"I made this about two years ago and even though I liked the outcome pretty much I decided not to post anything about it at the time.\nI didn\u0026rsquo;t want to harm in any way the company that makes the original but at this point it doesn\u0026rsquo;t make any sense to hold back, googling \u0026ldquo;plywood connectors\u0026rdquo; or \u0026ldquo;wood connectors DIY furniture\u0026rdquo; you will find a vast amount of chinese knockoffs.\nAt the time of writing I found this on the internet. Another interesting thing I found was this aluminium version where they claim to be in bussines since 2013.\nI first learned about this by the name of playwood. I found it when I was looking for a small bookshelf DIY project. There are some reasons why I didn\u0026rsquo;t buy directly from this guys. First, they are not super expensive but you need quite a few in order to make something useful, then, with post and import taxes it start to become expensive. Second, I have 3d printers and I like to make stuff.\nAs always, I kept the design as minimalist as possible. My version takes a socket head cap screw on one side and a hex nut on the other side. I\u0026rsquo;ve used M6 screws because it was what I had at hand at the time but I\u0026rsquo;m pretty sure smaller screws are also Ok for this application.\nimport cadquery as cq from math import cos, sqrt, pi # shared parameters thickness = 12.0 # mm width = 16.0 # mm screw_clearance = 6.8 # mm, diameter of the screw + some clearance # outer jaw parameters oface_length = 38.0 # mm, outer face length oleg_length = 42.0 # mm, outer leg length support_height = 4.0 # mm, I\u0026#39;m calling support this small bump where the plywood butt will rest against # minimum plywood thickness it will hold = sqrt(2)*support_height BTW counterBore_diameter = 11.2 # mm screwHead_height = 6.0 # mm # inner jaw parameters  # This inner leg lenght is just a recomendation, it will be flush with the outer jaw leg ileg_length = oleg_length-(thickness+support_height)*sqrt(2) # mm #inner jaw hardware parameters nut_thickness = 5.0 # mm nut_widthAcrossCorners = 12.0 # mm ojaw = (cq.Workplane(\u0026#34;front\u0026#34;).line(-oface_length/2, 0). line(-cos(pi/4)*oleg_length, cos(pi/4)*oleg_length). line(thickness*sqrt(2), 0). line((cos(pi/4)*oleg_length-thickness), -cos(pi/4)*oleg_length+thickness). line(support_height, support_height). lineTo(0, thickness+support_height).mirrorY().extrude(width). faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().cboreHole(screw_clearance, counterBore_diameter, screwHead_height)) ijaw = (cq.Workplane(\u0026#34;front\u0026#34;).line(-(oface_length-(thickness*sqrt(2)-thickness)*2-support_height*2)/2, 0). line(-cos(pi/4)*ileg_length, cos(pi/4)*ileg_length). line(thickness, 0). line((cos(pi/4)*ileg_length-thickness), -cos(pi/4)*ileg_length+thickness). lineTo(0, thickness).mirrorY().extrude(width). faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().hole(screw_clearance). faces(\u0026#34;\u0026gt;Y[-2]\u0026#34;).workplane().polygon(6, nut_widthAcrossCorners).cutBlind(-nut_thickness). translate((0,thickness+support_height,0))) show_object(ojaw) show_object(ijaw) Thanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2020-05-13-plywood-connector/","tags":["cadquery","python","3D printing","CAD"],"title":"Plywood Connectors"},{"categories":["Computer Aided Design"],"contents":"I had the idea to make a 3d printed bedside lamp as a b-day present for my friend Akarsh.\nI wanted something simple to print using vase mode. I wanted to take advantage of the good finish my kossel RepRap produces when printing in this mode. Also things are a bit easier this way because only a solid model is needed as the shell operation is carried out by the slicer software.\nI got really close of what I wanted with this cadquery one liner\nimport cadquery as cq lampshade = cq.Workplane(\u0026#34;front\u0026#34;).rect(150.0/1.618, 150.0).twistExtrude(150, 90) show_object(lampshade) Frankly, this was already very good but I wanted something else. After some bricolage of lofts on the top faces I got to something that I was happy with and printed it.\nIt ended up at my living room though. After printing I had the impression this design was better suited for living rooms than bedrooms. It was a bit big, I wanted something smaller. Also I was not so happy with the bottom side having the same dimensions as the top side. Some people that I have asked opinion liked it, but I didn\u0026rsquo;t. I got back to drawing board and this was the final result. (The picture below is a replica that I made for myself)\nimport cadquery as cq length = 150.0 # mm max_height = 150.0 # mm height_increment = 15.0 # mm, Z axis increment per step step_rotation = 10 # degrees, rotation of the XY plane per step growth_factor = 1.1 # maybe decrease factor ? ¯\\_(ツ)_/¯ spiral_lampshade = cq.Workplane(\u0026#34;front\u0026#34;).rect(length/1.618, length) .\\ workplane(offset=height_increment).rect(length/1.618, length) .\\ loft(combine=True) next_len = float (0) height = float (0) while height \u0026lt;= max_height-height_increment: next_len = length/growth_factor spiral_lampshade = spiral_lampshade.faces(\u0026#34;\u0026gt;Z\u0026#34;).rect(length/1.618, length).workplane().transformed(offset=(0, 0, height_increment), rotate=(0, 0, step_rotation)).rect(next_len/1.618, next_len).loft(combine=True) length = next_len height = height+height_increment show_object(spiral_lampshade) Thanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2020-05-12-parametric-lampshade/","tags":["cadquery","python","3D printing","CAD"],"title":"Parametric Spiral Lampshade"},{"categories":["Computer Aided Design"],"contents":"I\u0026rsquo;m revisiting my dovetail jig because when I was looking at Cadquery 2.0 documentation I saw the option to add text. I thought this model would benefit from having the ratio embossed on the top.\nimport cadquery as cq # A simple dovetail saw guide for woodworking  size = 40.0 # mm, size of the blank  ratio = 6 # dovetail ratio e.g. 1:6. tab_top = 15.0 # mm, thickness of the top tab tab_back = 15.0 # mm, thickness of the back tab magnet_diameter = 5.2 # mm magnet_thickness = 8.5 # mm  magnet_spacing_between = 24.0 # mm embossing = True dovetail_guide = cq.Workplane(\u0026#34;top\u0026#34;).rect(size, size).workplane(offset=size).rect(size-(size/float (ratio))*2, size).loft(combine=True) .\\ faces(\u0026#34;\u0026gt;X\u0026#34;).workplane().pushPoints([(-magnet_spacing_between/2, size/2-tab_top/2), (magnet_spacing_between/2, size/2-tab_top/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026lt;X\u0026#34;).workplane().pushPoints([(size/2-tab_back/2, magnet_spacing_between/2), (size/2-tab_back/2, -magnet_spacing_between/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().transformed(offset=(0, -tab_top, 0)).rect(size, size).cutBlind(-size+tab_back) if embossing: dovetail_guide = dovetail_guide.faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane(centerOption = \u0026#39;CenterOfBoundBox\u0026#39;).text(\u0026#34;1:\u0026#34;+str(ratio), 8, -1, cut=True, combine=False, clean=True, font=\u0026#39;Arial\u0026#39;, kind=\u0026#39;regular\u0026#39;, halign=\u0026#39;center\u0026#39;, valign=\u0026#39;center\u0026#39;) show_object(dovetail_guide) Neat, just neat. Nothing else to say :)\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2020-05-08-dovetail-jg-revisited/","tags":["cadquery","python","3D printing","CAD"],"title":"Dovetail Jig Revisited"},{"categories":["Computer Aided Design"],"contents":"The idea here is the same as my dovetail jig but now one is inteded to aid making square cuts on wood with hand saws and the other 45 degrees cut for joinery.\nI put the option of having a recess on this two jigs for clearance between the saw and the jig itself. I realized that depending on how you execute the cut the saw may bite the jig. It doesn\u0026rsquo;t alter the performance of the jig, but it leaves scratch marks. Cutting a recess on the dovetail jig makes it unbalanced but this two not, at least in my opinion.\nimport cadquery as cq # A simple woodworking jig for guiding a saw at right angles.  size = 50.0 # mm, size of the blank width = 35.0 # mm tab_top = 18.0 # mm, thickness of the top tab tab_back = 12.0 # mm, thickness of the back tab magnet_diameter = 5.2 # mm magnet_thickness = 8.5 # mm  magnet_spacing_between = 30.0 # mm clearance = True clearance_size = 2.0 # mm right_angle_guide = cq.Workplane(\u0026#34;top\u0026#34;).box(width, size, size).\\ faces(\u0026#34;\u0026gt;X\u0026#34;).workplane().pushPoints([(-magnet_spacing_between/2, size/2-tab_top/2), (magnet_spacing_between/2, size/2-tab_top/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().transformed(offset=(0, -tab_top, 0)).rect(size, size).cutBlind(-size+tab_back) if clearance: right_angle_guide = right_angle_guide.faces(\u0026#34;\u0026gt;X\u0026#34;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -tab_top).rect(size, size).cutBlind(-clearance_size) show_object(right_angle_guide) import cadquery as cq # A simple 45 degrees hand saw guide for woodworking  size = 40.0 # mm, height and lenght and of the guide. The width is double this value tab_top = 18.0 # mm, thickness of the top tab tab_back = 12.0 # mm, thickness of the back tab magnet_diameter = 5.2 # mm magnet_thickness = 8.5 # mm  magnet_spacing_between = 30.0 # mm clearance = True clearance_size = 2.0 # mm guide = cq.Workplane(\u0026#34;front\u0026#34;).lineTo(size*2, 0).lineTo(size, size).close().extrude(size) .\\ faces(\u0026#34;\u0026gt;X\u0026#34;).workplane().pushPoints([(-magnet_spacing_between/2, size/2-tab_top/2), (magnet_spacing_between/2, size/2-tab_top/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().transformed(offset=(0, -tab_top, -tab_back)).rect(size*2, size).cutBlind(-size) if clearance: guide = guide.faces(\u0026#39;\u0026gt;(1,1,0)\u0026#39;).workplane(centerOption=\u0026#39;CenterOfBoundBox\u0026#39;).move(0, -tab_top).rect(size*1.6, size).cutBlind(-clearance_size) show_object(guide) Recently I got myself a Gyokucho 615 and I could test it with the jig. No need to say it works like a charm. The cut was square and the texture of the end grain after the cut was very smooth. What a saw, btw! I managed to make a few frames with this setup.\nEven though the jigs are simple designs, I think it is a good example of how cool cadquery is. A few lines of human readable code and you have an useful parametric model ready for 3d printing or cnc machining. Iterate the design is fast and easy.\nThanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2020-05-08-sawing-guides/","tags":["cadquery","python","3D printing","CAD"],"title":"Sawing Guides"},{"categories":["Computer Aided Design"],"contents":"This is my take on dovetail guides, I designed this to be 3d printed and parametric. Using parametric design makes it very easy to tune the dovetail ratio and to fit different magnets that one may have at hand. Higher ratios (e.g 1:8) are good for hard woods and lower ratios (e.g. 1:5) are better suited for soft woods.\nSeveral models can be found on the internet and I would like to buy one but with all the import taxes it becomes expensive. Also I don\u0026rsquo;t know what ratio I want exactly, so it makes sense to print my own to experiment with.\nI was particularly inspired by David Barron and as seen is his videos, the simple jig works with magnets that holds the saw in place. This makes the dovetail cutting process easier for woodworking hobbyists like me.\nimport cadquery as cq # A simple dovetail saw guide for woodworking  size = 45.0 # mm, size of the blank  ratio = 6 # dovetail ratio e.g. 1:6. script is good for \u0026gt;2 tab_top = 15.0 # mm, thickness of the top tab tab_back = 15.0 # mm, thickness of the back tab magnet_diameter = 10.2 # mm magnet_thickness = 10.0 # mm  magnet_spacing_between = 24.0 # mm dovetail_guide = cq.Workplane(\u0026#34;top\u0026#34;).rect(size, size).workplane(offset=size).rect(size-(size/float (ratio))*2, size).loft(combine=True) .\\ faces(\u0026#34;\u0026gt;X\u0026#34;).workplane().pushPoints([(-magnet_spacing_between/2, size/2-tab_top/2), (magnet_spacing_between/2, size/2-tab_top/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026lt;X\u0026#34;).workplane().pushPoints([(size/2-tab_back/2, magnet_spacing_between/2), (size/2-tab_back/2, -magnet_spacing_between/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().transformed(offset=(0, -tab_top, 0)).rect(size, size).cutBlind(-size+tab_back) show_object(dovetail_guide) Thanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2019-04-01-dovetail-guide/","tags":["cadquery","python","3D printing","CAD"],"title":"Dovetail Guide"},{"categories":["Computer Aided Design"],"contents":"I always have been intrigued by horns. Actually by passive devices in general, tunned mass dampers, RLC circuits to name a few. Researching more about horns I found two designs that I\u0026rsquo;d like to explore more. One is the Kugelwellenhorn and the other is the Le Cleah\u0026rsquo;c horn. More info about the former can be found here, in a lecture apparently gaven by Le Cleach\u0026rsquo;c himself when he was still alive.\nAbout Kugellwellen horn, the design that I decided to approach first, all the info you need you can probably find in the site of Bjorn Kolbrek. Mr. Kolbrek seens to be an expert on subject, and I enjoyed a lot reading his articles. The math on his reports was a bit beyond my comprehension and I didn\u0026rsquo;t want to dive so deep into the subject. My goal was only to design and materialize the horn. Turns out that this is not hard at all, Just take a look at the script below and you\u0026rsquo;ll see that with about 30 lines of code is done. Amazing!. Well, again hats off to cadquery developers that make it possible.\nimport cadquery as cq import math import matplotlib.pyplot as plt c = 344000 # mm/s speed of sound through air fc = 480 # Hz cuttof frequency td = 12 # mm throat diameter steps = 450 # related to the length of the horn m = 4*math.pi*fc/c y0 = td/2 r0 = c/(math.pi*fc) h0 = r0 - math.sqrt(math.pow(r0, 2)-math.pow(y0, 2)) s0 = 2*math.pi*r0*h0 edg_points = [] for x in range(steps): h = h0*math.exp(m*x) s = 2*math.pi*r0*h y = math.sqrt((s/math.pi)-math.pow(h, 2)) xh = x-h+h0 edg_points.append([y, xh]) edg_points[0] = [y0, 0] fig, ax = plt.subplots() ax.plot(list(zip(*edg_points))[1], list(zip(*edg_points))[0]) ax.set(xlabel=\u0026#39;length (mm)\u0026#39;, ylabel=\u0026#39;contour (mm)\u0026#39;, title=\u0026#39;Kugelwellen horn profile\u0026#39;) ax.grid() plt.show() horn = cq.Workplane(\u0026#34;XY\u0026#34;).move(y0-0.01,0).spline(edg_points).wire().revolve() show_object(horn, options={\u0026#34;rgba\u0026#34;:(130, 185, 255, 0.0)}) One thing that\u0026rsquo;s interesting to notice, Mr. Lecleach suggests that it\u0026rsquo;s important to shape the horn past 180 degrees but as you can see it can be tricky to 3d print the involute part of the horn. Would be interesting to come up with some 3d printing hack to print the involute. Maybe one day I come back to this topic to try something in this direction.\nUPDATE (23/04/2020) Looking the script above that I wrote almost two years ago it\u0026rsquo;s easy to understand why it crashes in CQ 2.0. It\u0026rsquo;s a bit of a mess with this calling of matplotlib library. I must say it was convinient to look at the profile of the horn and to create the 3d model at the same time, but it\u0026rsquo;s ugly code.\nI was looking at the script to generate cycloid gears from Adam Urbanczyk, one of the developers of cadquery, and what an elegant code! This inspired me not only to remove this plotting part of the script, but also to modify it a bit in order to make it more elegant.\nimport cadquery as cq from math import pi, sqrt, exp td = 12 # mm, throat diameter steps = 400 # related to the length of the horn fc = 480 # Hz, cuttof frequency c = 344000 # mm/s, speed of sound through air m = 4*pi*fc/c y0 = td/2 r0 = c/(pi*fc) h0 = r0 - sqrt(r0*r0-y0*y0) s0 = 2*pi*r0*h0 edg_points = [] for x in range(steps): h = h0*exp(m*x) s = 2*pi*r0*h y = sqrt((s/pi)-h*h) xh = x-h+h0 edg_points.append([y, xh]) edg_points[0] = [y0, 0] horn = cq.Workplane(\u0026#34;XY\u0026#34;).move(y0, 0).spline(edg_points).wire().revolve() show_object(horn) Much better isn\u0026rsquo;t it ?\nThanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2018-08-19-kugelwellenhorn/","tags":["cadquery","python","3D printing","CAD"],"title":"Kugelwellenhorn"},{"categories":["Computer Aided Design"],"contents":"I had some old CDs lying around the house and I decided to organized them in a single place. I thought of 3d printing something to help, but after a brief search around the internet I couldn\u0026rsquo;t find anything that I liked. The ones I could find were big and clunky, leading to long printing times. The \u0026ldquo;simple\u0026rdquo; one (that wasn\u0026rsquo;t simple at all) that I found had the slots a bit undersized and I couldn\u0026rsquo;t fit the CDs. I could have rescaled the model but that print took me around 3 hours and I started to wonder if I should repeat it.\nI decided to come up with my own design.\nimport cadquery as cq slots = 8 # number slots (number of CDs in this case) slot_width = 11.0 # mm, slot size (slightly bigger than a CD case width)  slot_depth = 20.0 # mm slot_length = 140.0 # mm thickness_wall = 0.8 # mm thickness_bottom = 2.0 # mm spacing = slot_width + thickness_wall cdorg = cq.Workplane(\u0026#34;front\u0026#34;).box(slot_length+thickness_wall, spacing*slots+thickness_wall, slot_depth+thickness_bottom) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().center(thickness_wall,-(spacing/2*(slots-1))).pushPoints([(0, y * spacing) for y in range(0, slots)]).rect(slot_length+thickness_wall, slot_width).cutBlind(-slot_depth).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).rect(slot_length/1.6, spacing*slots+thickness_wall).cutBlind(-slot_depth) show_object(cdorg) The print took only 14 minutes cause I could take advantage of the 0.8mm nozzle and print the walls in a single pass of the hotend. The design turned out to be not super visually appealing but the function was on point. It keeps the CDs more accessible than just piling them up and it makes everything more stable against tipping over.\nMore important than the physical object itself was that I learned something. I find this method of using the for loop (python\u0026rsquo;s list comprehension) inside the pushPoints method very elegant and I plan to reuse this code for lathe tools and drill bits organizers among others.\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2018-08-18-cd-organizer/","tags":["cadquery","python","3D printing","CAD"],"title":"CD Organizer"},{"categories":["Computer Aided Design"],"contents":"Back in Brazil, during my machinist apprenticeship, one of the lathe tasks of the manual machining course was to make a turners cube. Basically you need to turn a cube in the lathe and make some holes, that if carefully bored to specific dimensions, you end up with usually two captive cubes inside one another. At the time I was only a young teenager and the captive cube was a very attractive challenge to me. I naively thought that only round parts could be made at the lathe, so I was impressed with the cube with other cubes inside coming out of the machine. Sadly nowadays I don\u0026rsquo;t know anymore where mine is. Hopefully at my mom\u0026rsquo;s place.\nYou can have as many cubes as you want inside. Back then, the ones who actually made the cube usually went for three, so I did and I still think that three is the right number if you\u0026rsquo;re doing it on the manual lathe. Two is too easy. Four is annoying because it is a lot of repetition of the same operations. Three is a good number because you proved your point in showing the instructor what you\u0026rsquo;re capable of, and is not as annoying to make as the four cubes version.\nLeaving 2003 behind and back to 2018, I was thinking that the repetitive nature of the object makes it a nice model for cadqquery. So here is the script that I came up with:\nimport cadquery as cq from math import sqrt captive_cube_size = 10 # mm n_of_cubes = 3 # besides the innermost captive cube small_holes = True # False = innermost captive cube without holes cube_size = captive_cube_size*2**n_of_cubes # total size of the cube sh_size = captive_cube_size/sqrt(2) # diameter of the hole on the smallest cube cube = cq.Workplane(\u0026#34;front\u0026#34;).box(cube_size, cube_size, cube_size) for x in range(n_of_cubes): cube = cube.faces(\u0026#34;\u0026gt;X\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;X\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) if small_holes: cube = cube.faces(\u0026#34;\u0026lt;X\u0026#34;).workplane().hole(sh_size) cube = cube.faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().hole(sh_size) cube = cube.faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().hole(sh_size) show_object(cube) I based my script in the innermost captive cube and in the square root of 2, which is a number associated with circles and squares. That makes the cube looks good and proportional. The drawback is that the final size grows quadratically with the number of cubes resulting in a big thing if you go for a lot of cubes.\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2018-07-04-cadquery-turners-cube/","tags":["cadquery","python","3D printing","CAD"],"title":"Cadquery Turners Cube"},{"categories":["Computer Aided Design"],"contents":"This is my debute 3d printing project. A chess set designed in cadquery.\n# Chess set import cadquery as cq # Chess board squares size cbss = 25 right_side_up_pawns = True # False is probably better for 3d printing # king base diameter and height kb = cbss*0.75 kh = kb*2.5 king = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).circle(kb*0.8/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.8/2).workplane(offset=kh*0.1).circle(kb*0.4/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.08).circle(kb*0.7/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.7/2).workplane(offset=kh*0.12).polygon(4, kb).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*0.75,kh*0.03).translate((0,cbss*3,0)) queen = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.5).circle(kb*0.6/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.6/2).workplane(offset=kh*0.12).circle(kb/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb/2).workplane(offset=kh*0.1).circle(kb*0.4/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.1).circle(kb*0.9/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*0.6,kh*0.03) .\\ faces(\u0026#34;\u0026gt;Z[-2]\u0026#34;).workplane().circle(kb*0.4/2).extrude(kh*0.05) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).fillet(kh*0.05-0.1).translate((0,cbss*4,0)) def rook(): rk = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).polygon(4, kb*1.6).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*1.2,kh*0.05) return rk def knight(): mouth = cq.Workplane(\u0026#34;top\u0026#34;).polygon(4, kb*0.8).extrude(kb*2).translate((kb*0.75,-kb,kb*1.3)) kn = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).center(-kb*0.1,0).polygon(2, kb*1.5).loft(combine=True) kn = kn.cut(mouth) return kn def bishop(): hat = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb*0.6/2).workplane(offset=kh*0.2).polygon(4,kb*1.2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).center(-kb*0.2,0).cskHole(kb*0.4,kb,72).translate((0,0,kh*0.5)) bi = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.5).circle(kb*0.6/2).loft(combine=True) bi = bi.add(hat).combine() return bi def pawn(): pa = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).extrude(kh*0.1) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.25).circle(kb/2).loft(combine=True) .\\ edges(\u0026#34;not\u0026gt;Z\u0026#34;).fillet(kb*0.1) if right_side_up_pawns: pa = pa.rotate((0,0,0), (1,0,0),180).translate((0,0,kh*0.35)) return pa Lrook = rook() Rrook = rook().translate((0, cbss*7, 0)) Lknight = knight().translate((0, cbss, 0)) Rknight = knight().translate((0, cbss*6, 0)) Lbishop = bishop().translate((0, cbss*2, 0)) Rbishop = bishop().translate((0, cbss*5, 0)) Lrook_pawn = pawn().translate((cbss, 0, 0)) Lknight_pawn = pawn().translate((cbss, cbss, 0)) Lbishop_pawn = pawn().translate((cbss, cbss*2, 0)) king_pawn = pawn().translate((cbss, cbss*3, 0)) queen_pawn = pawn().translate((cbss, cbss*4, 0)) Rbishop_pawn = pawn().translate((cbss, cbss*5, 0)) Rknight_pawn = pawn().translate((cbss, cbss*6, 0)) Rrook_pawn = pawn().translate((cbss, cbss*7, 0)) chess_set = king.add(queen).add(Lrook).add(Rrook).add(Lknight).add(Rknight) .\\ add(Lbishop).add(Rbishop).add(Lrook_pawn).add(Lknight_pawn) .\\ add(Lbishop_pawn).add(king_pawn).add(queen_pawn).add(Rbishop_pawn) .\\ add(Rknight_pawn).add(Rrook_pawn).combine() #show #show_object(Lrook, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lknight, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lbishop, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(queen, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(king, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rbishop, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rknight, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rrook, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lrook_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lknight_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lbishop_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(king_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(queen_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rbishop_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rknight_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rrook_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) show_object(chess_set, options={\u0026#34;rgba\u0026#34;:(130, 185, 255, 0.0)}) Some final comments about the script: I read an article here to more or less have some guidance about the parameters. The diameter of the bottom of the pieces should be 75% of the playing square and the height should be 2.5 x that number. They call this the 75% guideline.\nIt\u0026rsquo;s a bit unusual object to draw using parametric CAD and probably easier with point and click softwares but it was an interesting parametric exercise. I had a lot of fun coding the pieces and printing them.\nThanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2018-06-26-cadquery-chess-set/","tags":["cadquery","python","3D printing","CAD"],"title":"Cadquery Chess Set"}]