[{"categories":["Computer Aided Design"],"contents":"This is my take on dovetail guides, I designed this to be 3d printed and parametric. Using parametric design makes it very easy to tune the dovetail ratio and to fit different magnets that one may have at hand. Higher ratios (e.g 1:8) are good for hard woods and lower ratios (e.g. 1:5) are better suited for soft woods.\nI was inspired by David Barron and as seen is his videos, the simple jig works with magnets that holds the saw in position. This makes the dovetail cutting process easier for woodworking hobbyists like me.\nA 45Â° jig can also be easily made by using a ratio of 1:2. However the script crashes if you use an integer or \u0026ldquo;2.0\u0026rdquo; because you don\u0026rsquo;t have a rectangle anymore but an edge. A quick walk around is to use a float like \u0026ldquo;2.0001\u0026rdquo;. Not very elegant but gets the job done.\nimport cadquery as cq # A simple dovetail saw guide for woodworking  size = 45.0 # mm, size of the blank  ratio = 6.0 # dovetail ratio e.g. 1:6 tab_top = 15.0 # mm, thickness of the top tab tab_back = 15.0 # mm, thickness of the back tab magnet_diameter = 10.2 # mm magnet_thickness = 10.0 # mm  magnet_spacing_between = 24.0 # mm dovetail_guide = cq.Workplane(\u0026#34;top\u0026#34;).rect(size, size).workplane(offset=size).rect(size-(size/ratio)*2, size).loft(combine=True) .\\ faces(\u0026#34;\u0026gt;X\u0026#34;).workplane().pushPoints([(-magnet_spacing_between/2, size/2-tab_top/2), (magnet_spacing_between/2, size/2-tab_top/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026lt;X\u0026#34;).workplane().pushPoints([(size/2-tab_back/2, magnet_spacing_between/2), (size/2-tab_back/2, -magnet_spacing_between/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().transformed(offset=(0, -tab_top, 0)).rect(size, size).cutBlind(-size+tab_back) show_object(dovetail_guide) UPDATE (23/04/2020) Being lock down by the corona pandemic I took the time to improve things a bit. Now all the cadquery scripts on the website should be compatible with CQ 2.0.\nI also took the time to modify the script in order to create a right angle sawing guide. This one is inteded to aid making square cuts on wood with hand saws.\nRecently I got myself a Gyokucho 615 and I could test it with the jig. No need to say it works like a charm. The cut was square and the texture of the end grain after the cut was very smooth. What a saw, btw!\nI put 3 holes there so it fits right and left handed woodworkers.\nimport cadquery as cq # A simple woodworking jig for guiding a saw at right angles.  size = 50.0 # mm, size of the blank width = 35.0 # mm tab_top = 18.0 # mm, thickness of the top tab tab_back = 12.0 # mm, thickness of the back tab magnet_diameter = 10.2 # mm magnet_thickness = 10.0 # mm  magnet_spacing_between = 30.0 # mm right_angle_guide = cq.Workplane(\u0026#34;top\u0026#34;).box(width, size, size).\\ faces(\u0026#34;\u0026gt;X\u0026#34;).workplane().pushPoints([(-magnet_spacing_between/2, size/2-tab_top/2), (magnet_spacing_between/2, size/2-tab_top/2), (-size/2+tab_back/2, -magnet_spacing_between/2)]).hole(magnet_diameter, magnet_thickness) .\\ faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().transformed(offset=(0, -tab_top, 0)).rect(size, size).cutBlind(-size+tab_back) show_object(right_angle_guide) Even though this is a simple design I think it is good example of how cool cadquery is. A few lines of human readable code and you have an useful parametric model ready for 3d printing or cnc machining. Iterate the design is fast and easy.\nThanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2019-04-01-dovetail-guide/","tags":["cadquery","python","3D printing","CAD"],"title":"Dovetail Guide"},{"categories":["Computer Aided Design"],"contents":"I always have been intrigued by horns. Acctualy by passive devices in general, tunned mass dampers, RLC circuits to name a few. Researching more about horns I found two designs that I\u0026rsquo;d like to explore more. One is the Kugelwellenhorn and the other is the Le Cleah\u0026rsquo;c horn. More info about the former can be found here, in a lecture apparently gaven by Le Cleach\u0026rsquo;c himself when he was still alive.\nAbout Kugellwellen horn, the design that I decided to approach first, all the info you need you can probably find in the site of Bjorn Kolbrek. Mr. Kolbrek seens to be an expert on subject, and I enjoyed a lot reading his articles. The math on his reports was a bit beyond my comprehension and I didn\u0026rsquo;t want to dive so deep into the subject. My goal was only to design and materialize the horn. Turns out that this is not hard at all, Just take a look at the script below and you\u0026rsquo;ll see that with about 30 lines of code is done. Amazing!. Well, again hats off to cadquery developers that make it possible.\nimport cadquery as cq import math import matplotlib.pyplot as plt c = 344000 # mm/s speed of sound through air fc = 480 # Hz cuttof frequency td = 12 # mm throat diameter steps = 450 # related to the length of the horn m = 4*math.pi*fc/c y0 = td/2 r0 = c/(math.pi*fc) h0 = r0 - math.sqrt(math.pow(r0, 2)-math.pow(y0, 2)) s0 = 2*math.pi*r0*h0 edg_points = [] for x in range(steps): h = h0*math.exp(m*x) s = 2*math.pi*r0*h y = math.sqrt((s/math.pi)-math.pow(h, 2)) xh = x-h+h0 edg_points.append([y, xh]) edg_points[0] = [y0, 0] fig, ax = plt.subplots() ax.plot(list(zip(*edg_points))[1], list(zip(*edg_points))[0]) ax.set(xlabel=\u0026#39;length (mm)\u0026#39;, ylabel=\u0026#39;contour (mm)\u0026#39;, title=\u0026#39;Kugelwellen horn profile\u0026#39;) ax.grid() plt.show() horn = cq.Workplane(\u0026#34;XY\u0026#34;).move(y0-0.01,0).spline(edg_points).wire().revolve() show_object(horn, options={\u0026#34;rgba\u0026#34;:(130, 185, 255, 0.0)}) One thing that\u0026rsquo;s interesting to notice, Mr. Lecleach suggests that it\u0026rsquo;s important to shape the horn past 180 degrees but as you can see it can be tricky to 3d print the involute part of the horn. Would be interesting to come up with some 3d printing hack to print the involute. Maybe one day I come back to this topic to try something in this direction.\nUPDATE (23/04/2020) Being lock down by the corona pandemic I took the time to improve things a bit. Now all the cadquery scripts on the website should be compatible with CQ 2.0.\nLooking the script above that I wrote almost two years ago it\u0026rsquo;s easy to understand why it crashes in CQ 2.0. It\u0026rsquo;s a bit of a mess with this calling of matplotlib library. I must say it was convinient to look at the profile of the horn and to create the 3d model at the same time, but it\u0026rsquo;s ugly code.\nI was looking at the script to generate cycloid gears from Adam Urbanczyk, one of the developers of cadquery, and what an elegant code! This inspired me not only to remove this plotting part of the script, but also to modify it a bit in order to make it more elegant.\nimport cadquery as cq from math import pi, sqrt, exp td = 12 # mm, throat diameter steps = 400 # related to the length of the horn fc = 480 # Hz, cuttof frequency c = 344000 # mm/s, speed of sound through air m = 4*pi*fc/c y0 = td/2 r0 = c/(pi*fc) h0 = r0 - sqrt(r0*r0-y0*y0) s0 = 2*pi*r0*h0 edg_points = [] for x in range(steps): h = h0*exp(m*x) s = 2*pi*r0*h y = sqrt((s/pi)-h*h) xh = x-h+h0 edg_points.append([y, xh]) edg_points[0] = [y0, 0] horn = cq.Workplane(\u0026#34;XY\u0026#34;).move(y0, 0).spline(edg_points).wire().revolve() show_object(horn) Much better isn\u0026rsquo;t it ?\nThanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2018-08-19-kugelwellenhorn/","tags":["cadquery","python","3D printing","CAD"],"title":"Kugelwellenhorn"},{"categories":["Computer Aided Design"],"contents":"I had some old CDs lying around the house and I decided to organized them in a single place. I thought of 3d printing something to help, but after a brief search around the internet I couldn\u0026rsquo;t find anything that I liked. The ones I could find were big and clunky, leading to long printing times. The \u0026ldquo;simple\u0026rdquo; one (that wasn\u0026rsquo;t simple at all) that I found had the slots a bit undersized and I couldn\u0026rsquo;t fit the CDs. I could have rescaled the model but that print took me around 3 hours and I started to wonder if I should repeat it.\nI decided to come up with my own design.\nimport cadquery as cq slots = 8 # number slots (number of CDs in this case) slot_width = 11.0 # mm, slot size (slightly bigger than a CD case width)  slot_depth = 20.0 # mm slot_length = 140.0 # mm thickness_wall = 0.8 # mm thickness_bottom = 2.0 # mm spacing = slot_width + thickness_wall cdorg = cq.Workplane(\u0026#34;front\u0026#34;).box(slot_length+thickness_wall, spacing*slots+thickness_wall, slot_depth+thickness_bottom) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().center(thickness_wall,-(spacing/2*(slots-1))).pushPoints([(0, y * spacing) for y in range(0, slots)]).rect(slot_length+thickness_wall, slot_width).cutBlind(-slot_depth).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).rect(slot_length/1.6, spacing*slots+thickness_wall).cutBlind(-slot_depth) show_object(cdorg) The print took only 14 minutes cause I could take advantage of the 0.8mm nozzle and print the walls in a single pass of the hotend. The design turned out to be not super visually appealing but the function was on point. It keeps the CDs more accessible than just piling them up and it makes everything more stable against tipping over.\nMore important than the physical object itself was that I learned something. I find this method of using the for loop (python\u0026rsquo;s list comprehension) inside the pushPoints method very elegant and I plan to reuse this code for lathe tools and drill bits organizers among others.\nUPDATE (23/04/2020) Being lock down by the corona pandemic I took the time to improve things a bit. Now all the cadquery scripts on the website should be compatible with CQ 2.0.\nThanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2018-08-18-cd-organizer/","tags":["cadquery","python","3D printing","CAD"],"title":"CD organizer"},{"categories":["Computer Aided Design"],"contents":"Back in Brazil, during my machinist apprenticeship, one of the lathe tasks of the manual machining course was to make a turners cube. Basically you need to turn a cube in the lathe and make some holes, that if carefully bored to specific dimensions, you end up with usually two captive cubes inside one another. At the time I was only a young teenager and the captive cube was a very attractive challenge to me. I naively thought that only round parts could be made at the lathe, so I was impressed with the cube with other cubes inside coming out of the machine. Sadly nowadays I don\u0026rsquo;t know anymore where mine is. Hopefully at my mom\u0026rsquo;s house.\nYou can have as many cubes as you want inside. Back then, the ones who actually made the cube usually went for three, so I did and I still think that three is the right number if you\u0026rsquo;re doing it on the manual lathe. Two is too easy. Four is annoying because it is a lot of repetition of the same operations. Three is a good number because you proved your point in showing the instructor what you\u0026rsquo;re capable of, and is not as annoying to make as the four cubes version.\nLeaving 2003 behind and back to 2018, I was thinking that the parametric nature of the object makes it a nice model for cadqquery. So here is the script that I came up with:\nimport cadquery as cq from math import sqrt captive_cube_size = 10 # mm n_of_cubes = 3 # besides the innermost captive cube small_holes = True # False = innermost captive cube without holes cube_size = captive_cube_size*2**n_of_cubes # total size of the cube sh_size = captive_cube_size/sqrt(2) # diameter of the hole on the smallest cube cube = cq.Workplane(\u0026#34;front\u0026#34;).box(cube_size, cube_size, cube_size) for x in range(n_of_cubes): cube = cube.faces(\u0026#34;\u0026gt;X\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;X\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().hole(captive_cube_size*(sqrt(2)**(2*x+1)), (cube_size-captive_cube_size*2**x)/2) if small_holes: cube = cube.faces(\u0026#34;\u0026lt;X\u0026#34;).workplane().hole(sh_size) cube = cube.faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().hole(sh_size) cube = cube.faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().hole(sh_size) show_object(cube) I based my script in the innermost captive cube and in the square root of 2, which is a number associated with circles and squares. That makes the cube looks good and proportional. The drawback is that the final size grows quadratically with the number of cubes resulting in a big thing if you go for a lot of cubes.\nUPDATE (23/04/2020) Being lock down by the corona pandemic I took the time to improve things a bit. Now all the cadquery scripts on the website should be compatible with CQ 2.0.\nThanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2018-07-04-cadquery-turners-cube/","tags":["cadquery","python","3D printing","CAD"],"title":"Cadquery Turners Cube"},{"categories":["Computer Aided Design"],"contents":"This is my debute 3d printing project. A chess set designed in cadquery.\n# Chess set import cadquery as cq # Chess board squares size cbss = 25 right_side_up_pawns = True # False is probably better for 3d printing # king base diameter and height kb = cbss*0.75 kh = kb*2.5 king = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).circle(kb*0.8/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.8/2).workplane(offset=kh*0.1).circle(kb*0.4/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.08).circle(kb*0.7/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.7/2).workplane(offset=kh*0.12).polygon(4, kb).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*0.75,kh*0.03).translate((0,cbss*3,0)) queen = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.5).circle(kb*0.6/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.6/2).workplane(offset=kh*0.12).circle(kb/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb/2).workplane(offset=kh*0.1).circle(kb*0.4/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.1).circle(kb*0.9/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*0.6,kh*0.03) .\\ faces(\u0026#34;\u0026gt;Z[-2]\u0026#34;).workplane().circle(kb*0.4/2).extrude(kh*0.05) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).fillet(kh*0.05-0.1).translate((0,cbss*4,0)) def rook(): rk = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).polygon(4, kb*1.6).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*1.2,kh*0.05) return rk def knight(): mouth = cq.Workplane(\u0026#34;top\u0026#34;).polygon(4, kb*0.8).extrude(kb*2).translate((kb*0.75,-kb,kb*1.3)) kn = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).center(-kb*0.1,0).polygon(2, kb*1.5).loft(combine=True) kn = kn.cut(mouth) return kn def bishop(): hat = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb*0.6/2).workplane(offset=kh*0.2).polygon(4,kb*1.2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).center(-kb*0.2,0).cskHole(kb*0.4,kb,72).translate((0,0,kh*0.5)) bi = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.5).circle(kb*0.6/2).loft(combine=True) bi = bi.add(hat).combine() return bi def pawn(): pa = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).extrude(kh*0.1) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.25).circle(kb/2).loft(combine=True) .\\ edges(\u0026#34;not\u0026gt;Z\u0026#34;).fillet(kb*0.1) if right_side_up_pawns: pa = pa.rotate((0,0,0), (1,0,0),180).translate((0,0,kh*0.35)) return pa Lrook = rook() Rrook = rook().translate((0, cbss*7, 0)) Lknight = knight().translate((0, cbss, 0)) Rknight = knight().translate((0, cbss*6, 0)) Lbishop = bishop().translate((0, cbss*2, 0)) Rbishop = bishop().translate((0, cbss*5, 0)) Lrook_pawn = pawn().translate((cbss, 0, 0)) Lknight_pawn = pawn().translate((cbss, cbss, 0)) Lbishop_pawn = pawn().translate((cbss, cbss*2, 0)) king_pawn = pawn().translate((cbss, cbss*3, 0)) queen_pawn = pawn().translate((cbss, cbss*4, 0)) Rbishop_pawn = pawn().translate((cbss, cbss*5, 0)) Rknight_pawn = pawn().translate((cbss, cbss*6, 0)) Rrook_pawn = pawn().translate((cbss, cbss*7, 0)) chess_set = king.add(queen).add(Lrook).add(Rrook).add(Lknight).add(Rknight) .\\ add(Lbishop).add(Rbishop).add(Lrook_pawn).add(Lknight_pawn) .\\ add(Lbishop_pawn).add(king_pawn).add(queen_pawn).add(Rbishop_pawn) .\\ add(Rknight_pawn).add(Rrook_pawn).combine() #show #show_object(Lrook, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lknight, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lbishop, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(queen, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(king, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rbishop, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rknight, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rrook, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lrook_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lknight_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lbishop_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(king_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(queen_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rbishop_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rknight_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rrook_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) show_object(chess_set, options={\u0026#34;rgba\u0026#34;:(130, 185, 255, 0.0)}) Some final comments about the script: I read an article here to more or less have some guidance about the parameters. The diameter of the bottom of the pieces should be 75% of the playing square and the height should be 2.5 x that number. They call this the 75% guideline.\nIt\u0026rsquo;s a bit unusual object to draw using parametric CAD and probably easier with point and click softwares but it was an interesting parametric exercise. I had a lot of fun coding the pieces and printing them.\nThanks for looking\nEdi\n","permalink":"https://eddieliberato.github.io/blog/2018-06-26-cadquery-chess-set/","tags":["cadquery","python","3D printing","CAD"],"title":"Cadquery Chess Set"}]