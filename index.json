[{"categories":null,"contents":"Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet,\nconsetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam\nnonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd\n","permalink":"https://examplesite.com/about/about/","tags":null,"title":"About Me"},{"categories":["Computer Aided Design"],"contents":"My take on dovetail guides. I designed this to be 3d printed and parametric. Using parametric design makes it very easy to tune the dovetail ratio. Higher ratios (e.g 1:8) are good for hard woods and lower ratios (e.g. 1:5) are better suited for soft woods.\nI was inspired by David Barron, so the ideia is the same, magnets holds the saw in position and this should make the dovetail cutting process easier for woodworking hobbyists like me.\nimport cadquery as cq size = 50.0 #mm ratio = 6.0 #dovetail ratio e.g. 1:6 magtab = 20.0 #thickness of the magnet tab backtab = 20.0 #thickness of the back tab width = 40.0 magnet_dia = 14.3 magthick = 4.0 guide = cq.Workplane(\u0026#34;top\u0026#34;).rect(size, size).workplane(offset=size).rect(size-(size/ratio)*2, size).loft(combine=True) .\\ faces(\u0026#34;\u0026gt;X\u0026#34;).workplane().pushPoints([(-12,15), (12,15)]).hole(magnet_dia,magthick) .\\ faces(\u0026#34;\u0026lt;X\u0026#34;).workplane().pushPoints([(15,12), (15,-12)]).hole(magnet_dia,magthick) .\\ faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().transformed(offset=(0, -size/2, -backtab)).rect(size,-(size-magtab)*2).cutThruAll() # edges(\u0026#34;\u0026gt;Z or \u0026lt;Y or \u0026lt;Z or \u0026gt;Y\u0026#34;).chamfer(2) show_object(guide, options={\u0026#34;rgba\u0026#34;:(130, 185, 255, 0.0)}) Thanks for looking\nEdi Liberato\n","permalink":"https://examplesite.com/blog/2019-04-01-dovetail-guide/","tags":["cadquery","python","3D printing","CAD"],"title":"Dovetail Guide"},{"categories":["Computer Aided Design"],"contents":"I always have been intrigued by horns. Acctualy by passive devices in general, tunned mass dampers, RLC circuits, the anglepoise lamp to name a few. Researching more about horns I found two designs that I\u0026rsquo;d like to explore more. One is the Kugelwellenhorn and the other is the Le Cleah\u0026rsquo;c horn. More info about the former can be found here, in a lecture apparently gaven by Le Cleach\u0026rsquo;c himself when he was still alive. All the info about KugelWellen horn I read was from h\nAbout Kugellwellen horn, the design that I decided to approach first, all the info you need you can probably find in the site of Bjorn Kolbrek. Mr. Kolbrek seens to be an expert on subject, and I enjoyed a lot reading his articles. The math on his reports was a bit beyond my comprehension and I didn\u0026rsquo;t want to dive so deep into the subject. My goal was only to design and materialize the horn. Turns out that this is hard at all, Just take a look at the script below and you\u0026rsquo;ll see that with about 30 lines of code is done. Amazing!. Well, again hats off to cadquery developers that make it possible to in a few lines\nimport cadquery as cq import math import matplotlib.pyplot as plt c = 344000 # mm/s speed of sound through air fc = 480 # Hz cuttof frequency td = 12 # mm throat diameter steps = 450 # related to the length of the horn m = 4*math.pi*fc/c y0 = td/2 r0 = c/(math.pi*fc) h0 = r0 - math.sqrt(math.pow(r0, 2)-math.pow(y0, 2)) s0 = 2*math.pi*r0*h0 edg_points = [] for x in range(steps): h = h0*math.exp(m*x) s = 2*math.pi*r0*h y = math.sqrt((s/math.pi)-math.pow(h, 2)) xh = x-h+h0 edg_points.append([y, xh]) edg_points[0] = [y0, 0] fig, ax = plt.subplots() ax.plot(list(zip(*edg_points))[1], list(zip(*edg_points))[0]) ax.set(xlabel=\u0026#39;length (mm)\u0026#39;, ylabel=\u0026#39;contour (mm)\u0026#39;, title=\u0026#39;Kugelwellen horn profile\u0026#39;) ax.grid() plt.show() horn = cq.Workplane(\u0026#34;XY\u0026#34;).move(y0-0.01,0).spline(edg_points).wire().revolve() show_object(horn, options={\u0026#34;rgba\u0026#34;:(130, 185, 255, 0.0)}) The designed profile (just as example, not the 3d printed one shown in the pictures below)\nAfter printing\nOne thing that\u0026rsquo;s interesting to notice, Mr. Lecleach suggests that it\u0026rsquo;s important to shape the horn past 180 degrees but as you can see it can be tricky to 3d print the involute part of the horn. Would be interesting to come up with some 3d printing hack to print the involute. Maybe one day I come back to this topic to try something in this direction.\nThanks for looking\nEdi Liberato\n","permalink":"https://examplesite.com/blog/2018-08-19-kugelwellenhorn/","tags":["cadquery","python","3D printing","CAD"],"title":"Kugelwellenhorn"},{"categories":["Computer Aided Design"],"contents":"I had some old CDs lying around the house and I decided to organized them in a single place. I thought of 3d printing something to help, but after a brief search around the internet I couldn\u0026rsquo;t find something that I liked. The ones I could find were big and clunky, leading to long printing times. The simple one that I found had the slots a bit undersized and I couldn\u0026rsquo;t fit the CDs. That print took around 3 hours and I didn\u0026rsquo;t want to repeat it, so I decided to come with my own design.\nimport cadquery as cq slots = 8 #number of CD slots gap = 11.0 #slot size for the CD wthick = 1.0 #wall thickness bthick = 1.8 #bottom thickness spacing = gap + wthick tswidth = spacing*slots cdorg = cq.Workplane(\u0026#34;front\u0026#34;).box(140+wthick,tswidth+wthick,20+bthick) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().center(wthick,-(spacing/2*(slots-1))) .\\ pushPoints([(0, y * spacing) for y in range(0, slots)]) .\\ rect(140+wthick, gap).cutBlind(-20.0) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).rect(140.0/1.6, tswidth+wthick).cutBlind(-20.0) show_object(cdorg, options={\u0026#34;rgba\u0026#34;:(130, 185, 255, 0.5)}) The result:\nAfter printing\nWith CDs\nI\u0026rsquo;m satisfied with the results. The print took only 14 minutes cause I could take advantage of the 0.8mm nozzle and print the walls in a single pass of the extruder. It\u0026rsquo;s not super visually appealing but it keeps the CDs more accessible than just piling them up and it makes everything more stable against tipping over.\nAlso, I find this method of using the for loop (python\u0026rsquo;s list comprehension) inside the pushPoints method very elegant, and I plan to explore it more for lathe tools and drill bits organizers.\nThanks for looking\nEdi Liberato\n","permalink":"https://examplesite.com/blog/2018-08-18-cd-organizer/","tags":["cadquery","python","3D printing","CAD"],"title":"CD organizer"},{"categories":["Computer Aided Design"],"contents":"Back in Brazil, during my machinist apprenticeship, one of the lathe tasks of the manual machining course was to make a turners cube. Basically you need to turn a cube in the lathe and make some holes, that if carefully bored to specific dimensions, you end with usually two captive cubes inside one another. At the time I was only a young teenager, and it was to me a very attractive challenge. I naively thought that only round parts could be made at the lathe, so I was impressed with the cube with other cubes inside coming out of the machine. Sadly nowadays I don\u0026rsquo;t know anymore where mine is. Hopefully at my mom\u0026rsquo;s house.\nBack to the point, being a parametric thing, you can have as many cubes as you want inside. Usually the ones who actually made the cube went for three, so I did and I still think that three is the right number. Two is too easy. Four is annoying because it is a lot of repetition of the same operations. Three is a good number because you proved your point in showing the instructor what you\u0026rsquo;re capable of, and is not as annoying to make as the four cubes version. Leaving 2003 behind and back to 2018, I was thinking that the parametric nature of the object makes it a nice model for cadqquery. So here is the script that I came up with:\nimport cadquery as cq import math captive_cube = 10 # mm n_of_cubes = 3 # besides the innermost captive cube small_holes = True # False for the smallest cube without holes csize = captive_cube*2**n_of_cubes sh_size = captive_cube/math.sqrt(2) cube = cq.Workplane(\u0026#34;front\u0026#34;).box(csize, csize, csize) for x in range(n_of_cubes): cube = cube.faces(\u0026#34;\u0026gt;X\u0026#34;).workplane().hole(captive_cube*(math.sqrt(2)**(2*x+1)), (csize-captive_cube*2**x)/2) cube = cube.faces(\u0026#34;\u0026gt;Y\u0026#34;).workplane().hole(captive_cube*(math.sqrt(2)**(2*x+1)), (csize-captive_cube*2**x)/2) cube = cube.faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().hole(captive_cube*(math.sqrt(2)**(2*x+1)), (csize-captive_cube*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;X\u0026#34;).workplane().hole(captive_cube*(math.sqrt(2)**(2*x+1)), (csize-captive_cube*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().hole(captive_cube*(math.sqrt(2)**(2*x+1)), (csize-captive_cube*2**x)/2) cube = cube.faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().hole(captive_cube*(math.sqrt(2)**(2*x+1)), (csize-captive_cube*2**x)/2) if small_holes: cube = cube.faces(\u0026#34;\u0026lt;X\u0026#34;).workplane().hole(sh_size) cube = cube.faces(\u0026#34;\u0026lt;Y\u0026#34;).workplane().hole(sh_size) cube = cube.faces(\u0026#34;\u0026lt;Z\u0026#34;).workplane().hole(sh_size) show_object(cube, options={\u0026#34;rgba\u0026#34;:(130, 185, 255, 0.5)}) I based my script in the innermost captive cube and in the square root of 2, which is a number associated with circles and squares. That makes the cube looks good and proportional. The drawback is that the final size grows quadratically with the number of cubes resulting in a big thing if you go for a lot of cubes.\nThanks for looking\nEdi Liberato\n","permalink":"https://examplesite.com/blog/2018-07-04-cadquery-turners-cube/","tags":["cadquery","python","3D printing","CAD"],"title":"Cadquery Turners Cube"},{"categories":["Computer Aided Design"],"contents":"Recently I decided to join the 3d printing world, so I got me one cheap 3d printer kit and started having some fun. After assembling everything and printing some test files I started thinking about 3d printing projects that could help machinists and toolmakers. Well that didn\u0026rsquo;t happen yet, but in the mean time my wife caught me watching a chess game on YouTube and said that I should teach her how to play. The problem was:\n I don\u0026rsquo;t have a chess set.\n But I immediately saw that was a good opportunity to involve 3d printing and cadquery, currently my favorite CAD software. After exactly 100 lines of code that\u0026rsquo;s the results:\n# Chess set import cadquery as cq # Chess board squares size cbss = 25 right_side_up_pawns = True # False is probably better for 3d printing # king base diameter and height kb = cbss*0.75 kh = kb*2.5 king = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).circle(kb*0.8/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.8/2).workplane(offset=kh*0.1).circle(kb*0.4/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.08).circle(kb*0.7/2).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.7/2).workplane(offset=kh*0.12).polygon(4, kb).loft(combine=True).\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*0.75,kh*0.03).translate((0,cbss*3,0)) queen = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.5).circle(kb*0.6/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.6/2).workplane(offset=kh*0.12).circle(kb/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb/2).workplane(offset=kh*0.1).circle(kb*0.4/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.1).circle(kb*0.9/2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*0.6,kh*0.03) .\\ faces(\u0026#34;\u0026gt;Z[-2]\u0026#34;).workplane().circle(kb*0.4/2).extrude(kh*0.05) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).fillet(kh*0.05-0.1).translate((0,cbss*4,0)) def rook(): rk = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).polygon(4, kb*1.6).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).hole(kb*1.2,kh*0.05) return rk def knight(): mouth = cq.Workplane(\u0026#34;top\u0026#34;).polygon(4, kb*0.8).extrude(kb*2).translate((kb*0.75,-kb,kb*1.3)) kn = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.7).center(-kb*0.1,0).polygon(2, kb*1.5).loft(combine=True) kn = kn.cut(mouth) return kn def bishop(): hat = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb*0.6/2).workplane(offset=kh*0.2).polygon(4,kb*1.2).loft(combine=True). \\ faces(\u0026#34;\u0026gt;Z\u0026#34;).center(-kb*0.2,0).cskHole(kb*0.4,kb,72).translate((0,0,kh*0.5)) bi = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).workplane(offset=kh*0.5).circle(kb*0.6/2).loft(combine=True) bi = bi.add(hat).combine() return bi def pawn(): pa = cq.Workplane(\u0026#34;front\u0026#34;).circle(kb/2).extrude(kh*0.1) .\\ faces(\u0026#34;\u0026gt;Z\u0026#34;).workplane().circle(kb*0.4/2).workplane(offset=kh*0.25).circle(kb/2).loft(combine=True) .\\ edges(\u0026#34;not\u0026gt;Z\u0026#34;).fillet(kb*0.1) if right_side_up_pawns: pa = pa.rotate((0,0,0), (1,0,0),180).translate((0,0,kh*0.35)) return pa Lrook = rook() Rrook = rook().translate((0, cbss*7, 0)) Lknight = knight().translate((0, cbss, 0)) Rknight = knight().translate((0, cbss*6, 0)) Lbishop = bishop().translate((0, cbss*2, 0)) Rbishop = bishop().translate((0, cbss*5, 0)) Lrook_pawn = pawn().translate((cbss, 0, 0)) Lknight_pawn = pawn().translate((cbss, cbss, 0)) Lbishop_pawn = pawn().translate((cbss, cbss*2, 0)) king_pawn = pawn().translate((cbss, cbss*3, 0)) queen_pawn = pawn().translate((cbss, cbss*4, 0)) Rbishop_pawn = pawn().translate((cbss, cbss*5, 0)) Rknight_pawn = pawn().translate((cbss, cbss*6, 0)) Rrook_pawn = pawn().translate((cbss, cbss*7, 0)) chess_set = king.add(queen).add(Lrook).add(Rrook).add(Lknight).add(Rknight) .\\ add(Lbishop).add(Rbishop).add(Lrook_pawn).add(Lknight_pawn) .\\ add(Lbishop_pawn).add(king_pawn).add(queen_pawn).add(Rbishop_pawn) .\\ add(Rknight_pawn).add(Rrook_pawn).combine() #show #show_object(Lrook, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lknight, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lbishop, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(queen, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(king, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rbishop, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rknight, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rrook, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lrook_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lknight_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Lbishop_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(king_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(queen_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rbishop_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rknight_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) #show_object(Rrook_pawn, options={\u0026#34;rgba\u0026#34;:(204, 204, 204, 0.0)}) show_object(chess_set, options={\u0026#34;rgba\u0026#34;:(130, 185, 255, 0.0)}) A cycles (blender) render\nThe 3d printed pieces\nSome final comments about the script: I read an article here to more or less have some guidance about the parameters. The diameter of the bottom of the pieces should be 75% of the playing square and the height should be 2.5 x that number. They call this the 75% guideline.\nIt\u0026rsquo;s a bit unusual object to draw using parametric CAD and probably easier with point and click softwares but it was an interesting parametric exercise. I had a lot of fun coding the pieces and printing them.\nThanks for looking\nEdi Liberato\n","permalink":"https://examplesite.com/blog/2018-06-26-cadquery-chess-set/","tags":["cadquery","python","3D printing","CAD"],"title":"Cadquery Chess Set"}]